# Continuous Integration
name: continuous-integration
run-name: CI pipeline for ${{ github.ref_name }}

on:
  # Runs on pushes targeting 'feature branches' (any branch that is NOT the default branch)
  push:
    branches-ignore: [main]

jobs:
  # Check feature (id#) has not been done before (in case local repo keeps using branch and then pushes)
  # If already done... then??? Maybe append "part 2" as pattern... to PR and release etc


  # Create PR for this feature (if does not exist)
  pr-ci: 
    name: PR Open-Reopen
    timeout-minutes: 10
    permissions:
      pull-requests: write
      issues: write
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      OWNER: ${{ github.repository_owner }}
      REPO_NAME: ${{ github.event.repository.name }}
      BRANCH: ${{ github.ref_name }}
    outputs:
      issue-id: ${{ steps.setoutput.outputs.ISSUE_ID }}
      pr-id: ${{ steps.setoutput.outputs.PR_ID }}
      semver-type: ${{ steps.setoutput.outputs.SEMVER }}
    steps:

      - name: Checkout 🛎️
        uses: actions/checkout@v3

      - name: New-Reopen-PR
        run: gh pr edit ${{ github.ref_name }} -b "Reopened by Github action" -t ${{ github.ref_name }} && gh pr reopen ${{ github.ref_name }} || gh pr create -b "Created by Github action" -t ${{ github.ref_name }} 

      - name: Get Issue + PR Number
        id: setoutput
        run: |
          issue_num="$(echo $BRANCH | sed 's@^[^0-9]*\([0-9]\+\).*@\1@')"
          echo "ISSUE_ID=$issue_num" >> $GITHUB_OUTPUT
          pr_num=$((issue_num + 1))
          echo "PR_ID=$pr_num" >> $GITHUB_OUTPUT
          labels_response="$(gh api repos/$OWNER/$REPO_NAME/issues/$issue_num --jq '.labels.[].name')" || "none"
          issue_labels=$(echo $labels_response | sed -z 's/\n/,/g;s/,$/\n/')
          echo "$issue_labels"
          echo "LABELS=$issue_labels" >> $GITHUB_OUTPUT
          echo "SEMVER='(PATCH)'" >> $GITHUB_OUTPUT

      - name: Add "automate" label
        # Used for autogenerated release notes
        if: ${{ contains(steps.setoutput.outputs.LABELS, 'automate') }}
        run: gh issue edit ${{steps.setoutput.outputs.PR_ID}} --add-label "automate"

      # TODO: Add the other label types

      - name: Major Version From Label
        # Used in PR merge commit message for tag+release workflow
        if: ${{ contains(steps.setoutput.outputs.LABELS, 'major-version') }}
        run: echo "SEMVER='(MAJOR)'" >> $GITHUB_OUTPUT

      - name: Minor Version From Label
        # Used in PR merge commit message for tag+release workflow
        if: ${{ contains(steps.setoutput.outputs.LABELS, 'minor-version') }}
        run: echo "SEMVER='(MINOR)'" >> $GITHUB_OUTPUT


  # Add data for metrics: "lead time to change" (first push to remote)

  # Update issue with comment (that PR is created with link to it)


  # Build static site using Reveal-MD
  build-ci:
    name: Build-CI
    needs: [pr-ci]
    uses: ./.github/workflows/reuse-build-revealmd.yml
    with: 
      branch-name: ${{ github.ref_name }}
      deploy-stage: 'ci'

  # (1) TODO: PR Checks for Build/Tests
  # https://sagarsonwane230797.medium.com/automate-build-checks-and-slack-notification-with-github-actions-3b7eb702dae6
  # https://josh-ops.com/posts/using-github-checks-api/


  # Merge PR if ready (note: by "[merge ci]" in message of final commit on feature branch)
  pr-merge-ci: 
    name: PR Merge CI
    needs: [pr-ci, build-ci]
    if: ${{ contains(github.event.head_commit.message, '[merge ci]') }}
    timeout-minutes: 10
    runs-on: ubuntu-latest    
    steps:

      - name: Checkout Feature Branch
        uses: actions/checkout@v3

      - name: Merge PR
        run: gh pr merge ${{ github.ref_name }} --squash --subject "${{ github.ref_name }} ${{ needs.pr-ci.outputs.semver-type }}" --body "Automerged by GitHub Action"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: GitHub Step Summary
        run: echo "### PR Merge Success! :thumbsup:" >> $GITHUB_STEP_SUMMARY    

      - name: Add Comment to Issue
        run: gh issue comment ${{ needs.pr-ci.outputs.issue-id }} --body "### 📣 Pull request ${{ needs.pr-ci.outputs.pr-id }} merged"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


  # Determine SemVer Tag and compare to version in Package.json
#  get-tag:
#    name: Tag and Release
#    needs: [pr-ci]
#    if: ${{ contains(github.event.head_commit.message, '[merge ci]') }}
#    permissions:
#      contents: write
#      issues: write
#    uses: ./.github/workflows/reuse-tag-release.yml


  # Determine SemVer Tag and compare to version in Package.json
  semver-output:
    name: Calculate SemVer Version and Compare to Package Version
    needs: [pr-merge-ci]
    timeout-minutes: 10
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      semver: ${{ steps.setoutput.outputs.SEMVER }}   
      package-version: ${{ steps.setoutput.outputs.NPM_TAG }}   
    steps:

      - name: Checkout Main Branch
        uses: actions/checkout@v3
        with:
          ref: 'main'
          fetch-depth: 0

      - name: Get Next Tag Version
        id: next-version
        uses: paulhatch/semantic-version@v5.0.3
        # https://github.com/PaulHatch/semantic-version
        with:
          tag_prefix: ''
          version_format: '${major}.${minor}.${patch}'

      - name: Get NPM Package Version
        id: package-version
        uses: martinbeentjes/npm-get-version-action@v1.2.3
        # https://github.com/martinbeentjes/npm-get-version-action

      - name: Set outputs
        id: setoutput
        run: | 
          echo "SemVer is ${{ steps.next-version.outputs.version_tag }}"
          echo "SEMVER=${{steps.next-version.outputs.version_tag}}" >> $GITHUB_OUTPUT
          echo "Package Version is ${{ steps.package-version.outputs.current-version }}"
          echo "NPM_TAG=${{steps.package-version.outputs.current-version}}" >> $GITHUB_OUTPUT    


  # If Package.json is not correct... then update it
  update-package-version:
    name: Update Package version
    needs: [semver-output]
    if: ${{ needs.semver-output.outputs.semver != needs.semver-output.outputs.package-version }}
    timeout-minutes: 10
    runs-on: ubuntu-latest  
    steps:

      - name: Checkout Main Branch
        uses: actions/checkout@v3
        with:
          ref: 'main'

      - name: Update Package.json
        run: |
          echo "SemVer is ${{ needs.semver-output.outputs.semver }}"
          echo "Package Version is ${{ needs.semver-output.outputs.package-version }}"
          git config user.name github-actions
          git config user.email github-actions@github.com
          npm version ${{ needs.semver-output.outputs.semver }}
          git add .
          git commit -m "package.json version updated to ${{ needs.semver-output.outputs.semver }}"
          git push


  # Create release using GitHub CLI (auto adds tag to commit and generates release notes)
  create-release-and-tag:
    name: Create Release and Tag Commit
    needs: [semver-output, update-package-version]
    timeout-minutes: 10
    runs-on: ubuntu-latest  
    steps:
      - name: Create Release and Tag Commit via GitHub CLI
        run: gh release create ${{ format('{0}{1}', 'v', needs.semver-output.outputs.semver) }} --generate-notes --latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}







  # (3) Dispatch to deploy to Stage
  # TODO: Setup repo for this and workflow
  # Stage repo workflow: 1) get build artifacts... 2) add stage config... 3) deploy to GHP... 4) do smoke testing
  # Workflow above calls each point above, which is a workflow in this repo (reuse)
  # Note: stage config shows that in stage (i.e. red background)
  # Note: Stage should have all contents (i.e. canary indicator)... which can get deleted in canary delployment
  
  # If smoke tests fail: notify PR team and Dev team and exit this workflow
  # PR team will delete that release in this repo
  # Could automate: 1) delete release... 2) trigger rollback workflow that builds and deploys usng last working commit SHA

  # Dev team notified via new issue with label
  # Rollback workflow updates this issue

  # Add data for metrics: "change failure rate" (this is a failure at stage... so log)
  # Add data for metrics: "mean time to recovery" from failure to rollback deployed in Stage

  # Dispatch to deploy to Canary
  # TODO: Setup repo for this and workflow (same as Stage)
  # Same smoke testing (aka PVT) and flow

  # Add data for metrics: "deployment frequency" (deployed to Canary as measure)
  # Add data for metrics: "lead time to change" (change in canary considered as change released to user)

  # End this workflow: From first push of feature change... to integration... to delivery via PR... to deployment to canary (aka Prod)


# Useful to checking jobs done before next job
#  merge-ready:
#    name: Merge Ready - Feature Branch to Truck
#    needs: [get-tag, update-package-version, build-ci]
#    if: |
#      always() &&
#      !contains(needs.*.result, 'failure') &&
#      !contains(needs.*.result, 'cancelled')
#    timeout-minutes: 10
#    runs-on: ubuntu-latest 
#    steps:
#      - name: Ready message
#        run: echo "### Merge Ready :thumbsup:" >> $GITHUB_STEP_SUMMARY   


# :-)